{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Libxslt Extension Modules Although libxml2 and libxslt are widely available, unfortunately they implement only XPath 1.0 and XSL-T 1.0. Therefore a lot of useful features are missing, particularly XPath functions. This collection implements various extension elements and functions for libxslt that have proved useful in a few projects. The functions or elements actually implemented follow no particular plan, rather they are somewhat randomly chosen based on immediate need over time. In principle the XPath extension functions are independent of libxslt and could be implemented using only libxml2, however the extension modules rely on the module loading mechanism in libxslt and so they are only available when used through an XSL-T stylesheet. They attempt to follow the specifications from exslt.org or XPath 2.0 functions where feasible, although some functions appear in neither specification. Since XPath 2.0 has a number of features not present in the libxml2 implementation, corresponding implementations are at most similar rather than identical. Copyright & Licence The Libxslt Extension Modules are copyright \u00a9 2020 Brian Stafford . They are released under the MIT Licence since this is the licence used by libxml2 and libxslt.","title":"Home"},{"location":"index.html#libxslt-extension-modules","text":"Although libxml2 and libxslt are widely available, unfortunately they implement only XPath 1.0 and XSL-T 1.0. Therefore a lot of useful features are missing, particularly XPath functions. This collection implements various extension elements and functions for libxslt that have proved useful in a few projects. The functions or elements actually implemented follow no particular plan, rather they are somewhat randomly chosen based on immediate need over time. In principle the XPath extension functions are independent of libxslt and could be implemented using only libxml2, however the extension modules rely on the module loading mechanism in libxslt and so they are only available when used through an XSL-T stylesheet. They attempt to follow the specifications from exslt.org or XPath 2.0 functions where feasible, although some functions appear in neither specification. Since XPath 2.0 has a number of features not present in the libxml2 implementation, corresponding implementations are at most similar rather than identical.","title":"Libxslt Extension Modules"},{"location":"index.html#copyright-licence","text":"The Libxslt Extension Modules are copyright \u00a9 2020 Brian Stafford . They are released under the MIT Licence since this is the licence used by libxml2 and libxslt.","title":"Copyright &amp; Licence"},{"location":"download.html","text":"Download The Libxslt Extension Modules are available from GitHub . Clone the repository as follows: $ git clone https://github.com/iarthair/xslt-extra.git Dependencies libxml2 The libxml2 development package is required to build the extension modules. If your distribution does not provide libxml2, you can download it here . libxslt The libxslt development package is required to build the extension modules. If your distribution does not provide libxml2, you can download it here . regcomp() Most modern C libraries provide the POSIX.1-2001, POSIX.1-2008 regcomp() family of functions, required to build the regular expression functions. Installation The libxslt extension functions use the Meson build system . Refer to the Meson manual for standard configuration options. Meson supports multiple build system backends. To build with Ninja do the following: $ meson [options] --buildtype=release builddir $ ninja -C builddir install Note that the meson/ninja installer does not require an explicit sudo , instead it will prompt for a password during install. This avoids polluting builddir with files owned by root. Reporting Bugs Bug should be reported using the GitHub issue tracker.","title":"Download"},{"location":"download.html#download","text":"The Libxslt Extension Modules are available from GitHub . Clone the repository as follows: $ git clone https://github.com/iarthair/xslt-extra.git","title":"Download"},{"location":"download.html#dependencies","text":"","title":"Dependencies"},{"location":"download.html#libxml2","text":"The libxml2 development package is required to build the extension modules. If your distribution does not provide libxml2, you can download it here .","title":"libxml2"},{"location":"download.html#libxslt","text":"The libxslt development package is required to build the extension modules. If your distribution does not provide libxml2, you can download it here .","title":"libxslt"},{"location":"download.html#regcomp","text":"Most modern C libraries provide the POSIX.1-2001, POSIX.1-2008 regcomp() family of functions, required to build the regular expression functions.","title":"regcomp()"},{"location":"download.html#installation","text":"The libxslt extension functions use the Meson build system . Refer to the Meson manual for standard configuration options. Meson supports multiple build system backends. To build with Ninja do the following: $ meson [options] --buildtype=release builddir $ ninja -C builddir install Note that the meson/ninja installer does not require an explicit sudo , instead it will prompt for a password during install. This avoids polluting builddir with files owned by root.","title":"Installation"},{"location":"download.html#reporting-bugs","text":"Bug should be reported using the GitHub issue tracker.","title":"Reporting Bugs"},{"location":"functions.html","text":"XPath String Functions string-join() xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:string-join(node-set,string?) Concatenate a list of strings with an intervening separator. The list of strings is specified by a node-set passed in the first argument. Each element in the node-set is converted to a string as if by using the XPath string() function. If the separator is not specified an empty string is used. Arguments node-set : A node-set converted to a list of strings. string ?: An optional separator string. If omitted an empty string is used. Returns string : the concatenated string ends-with() xmlns:fn=\"https://iarthair.github.io/xpfunctions\" boolean fn:ends-with(string,string) Test whether a string ends with the specified suffix. If either argument is not a string it is converted as if with the XPath string() function. Arguments string : String to test. string : Suffix to search for. Returns boolean : true if the test string has the specified suffix. class-match() xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:class-match(string, string?) Test whether the token specified in the second argument matches any of the space-separated tokens in the 1st argument. If either argument is not a string it is converted as if with the XPath string() function. Arguments string : list of space separated tokens. string : token to test. Returns boolean : true if the token matches.","title":"String"},{"location":"functions.html#xpath-string-functions","text":"","title":"XPath String Functions"},{"location":"functions.html#string-join","text":"xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:string-join(node-set,string?) Concatenate a list of strings with an intervening separator. The list of strings is specified by a node-set passed in the first argument. Each element in the node-set is converted to a string as if by using the XPath string() function. If the separator is not specified an empty string is used.","title":"string-join()"},{"location":"functions.html#arguments","text":"node-set : A node-set converted to a list of strings. string ?: An optional separator string. If omitted an empty string is used.","title":"Arguments"},{"location":"functions.html#returns","text":"string : the concatenated string","title":"Returns"},{"location":"functions.html#ends-with","text":"xmlns:fn=\"https://iarthair.github.io/xpfunctions\" boolean fn:ends-with(string,string) Test whether a string ends with the specified suffix. If either argument is not a string it is converted as if with the XPath string() function.","title":"ends-with()"},{"location":"functions.html#arguments_1","text":"string : String to test. string : Suffix to search for.","title":"Arguments"},{"location":"functions.html#returns_1","text":"boolean : true if the test string has the specified suffix.","title":"Returns"},{"location":"functions.html#class-match","text":"xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:class-match(string, string?) Test whether the token specified in the second argument matches any of the space-separated tokens in the 1st argument. If either argument is not a string it is converted as if with the XPath string() function.","title":"class-match()"},{"location":"functions.html#arguments_2","text":"string : list of space separated tokens. string : token to test.","title":"Arguments"},{"location":"functions.html#returns_2","text":"boolean : true if the token matches.","title":"Returns"},{"location":"lang.html","text":"RFC 4647 Language Tag Matching The following functions implement RFC 4647 language tag matching. In each function the range argument is a string of space separated language tags listed in order of decreasing preference. lang() xmlns:lang=\"https://iarthair.github.io/lang\" boolean lang:lang(string) Compare the context node's language against the range specified in the first argument. The language of a node is the value of xml:lang attribute or, if absent, the one carried by the nearest ancestor. This is similar to the XPath lang() function except that the comparison is guaranteed to be the algorithm described in RFC 4647 and consistent with the other functions in this namespace URI. Arguments string : the language range to accept. Returns boolean : true if the node is matched by the range. accept-lang() xmlns:lang=\"https://iarthair.github.io/lang\" node-set lang:accept-lang(node-set,string) Return a node-set of elements whose language is the most specific match for the range specified in the second argument. The language of a node is the value of xml:lang attribute or, if absent, the one carried by the nearest ancestor. Arguments node-set : the set of nodes to be matched. string : the language range to accept. Returns node-set : set of matching nodes. canonic-lang() xmlns:lang=\"https://iarthair.github.io/lang\" string lang:canonic-lang(string) Return the canonic form of the language tag in the argument string or an empty string if it is not a valid RFC 4646 tag. Arguments string : the language tag. Returns string : the canonic tag. extract-lang() xmlns:lang=\"https://iarthair.github.io/lang\" string lang:extract-lang(string) Return the language tag extracted from the string or an empty string if it is not a valid RFC 4646 tag. Arguments string : the language tag. Returns string : the canonic tag.","title":"Language Tags"},{"location":"lang.html#rfc-4647-language-tag-matching","text":"The following functions implement RFC 4647 language tag matching. In each function the range argument is a string of space separated language tags listed in order of decreasing preference.","title":"RFC 4647 Language Tag Matching"},{"location":"lang.html#lang","text":"xmlns:lang=\"https://iarthair.github.io/lang\" boolean lang:lang(string) Compare the context node's language against the range specified in the first argument. The language of a node is the value of xml:lang attribute or, if absent, the one carried by the nearest ancestor. This is similar to the XPath lang() function except that the comparison is guaranteed to be the algorithm described in RFC 4647 and consistent with the other functions in this namespace URI.","title":"lang()"},{"location":"lang.html#arguments","text":"string : the language range to accept.","title":"Arguments"},{"location":"lang.html#returns","text":"boolean : true if the node is matched by the range.","title":"Returns"},{"location":"lang.html#accept-lang","text":"xmlns:lang=\"https://iarthair.github.io/lang\" node-set lang:accept-lang(node-set,string) Return a node-set of elements whose language is the most specific match for the range specified in the second argument. The language of a node is the value of xml:lang attribute or, if absent, the one carried by the nearest ancestor.","title":"accept-lang()"},{"location":"lang.html#arguments_1","text":"node-set : the set of nodes to be matched. string : the language range to accept.","title":"Arguments"},{"location":"lang.html#returns_1","text":"node-set : set of matching nodes.","title":"Returns"},{"location":"lang.html#canonic-lang","text":"xmlns:lang=\"https://iarthair.github.io/lang\" string lang:canonic-lang(string) Return the canonic form of the language tag in the argument string or an empty string if it is not a valid RFC 4646 tag.","title":"canonic-lang()"},{"location":"lang.html#arguments_2","text":"string : the language tag.","title":"Arguments"},{"location":"lang.html#returns_2","text":"string : the canonic tag.","title":"Returns"},{"location":"lang.html#extract-lang","text":"xmlns:lang=\"https://iarthair.github.io/lang\" string lang:extract-lang(string) Return the language tag extracted from the string or an empty string if it is not a valid RFC 4646 tag.","title":"extract-lang()"},{"location":"lang.html#arguments_3","text":"string : the language tag.","title":"Arguments"},{"location":"lang.html#returns_3","text":"string : the canonic tag.","title":"Returns"},{"location":"license.html","text":"The MIT License Copyright \u00a9 2020 Brian Stafford Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License"},{"location":"license.html#the-mit-license","text":"Copyright \u00a9 2020 Brian Stafford Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License"},{"location":"lualibxslt.html","text":"XML and XSL-T access from Lua When using Lua from the <script> element, XML and XSLT types are automatically available when accessed via arguments passed to Lua functions. Additional functions described here are accessed using require \"libxslt\" . xslt = require \"libxslt\" nodeset = xslt.current() pos = xslt.position() pos = xslt.last() nodeset = xslt.nodeset() Functions current() Return a node-set containing the current XPath context node. Equivalent to the XPath current() function. position() Return a number equal to the context position from the current XPath expression evaluation context. Equivalent to the XPath position() function. last() Return a number equal to the context size from the current XPath expression evaluation context. Equivalent to the XPath last() function. nodeset() Return a new empty nodeset.","title":"Libxslt"},{"location":"lualibxslt.html#xml-and-xsl-t-access-from-lua","text":"When using Lua from the <script> element, XML and XSLT types are automatically available when accessed via arguments passed to Lua functions. Additional functions described here are accessed using require \"libxslt\" . xslt = require \"libxslt\" nodeset = xslt.current() pos = xslt.position() pos = xslt.last() nodeset = xslt.nodeset()","title":"XML and XSL-T access from Lua"},{"location":"lualibxslt.html#functions","text":"","title":"Functions"},{"location":"lualibxslt.html#current","text":"Return a node-set containing the current XPath context node. Equivalent to the XPath current() function.","title":"current()"},{"location":"lualibxslt.html#position","text":"Return a number equal to the context position from the current XPath expression evaluation context. Equivalent to the XPath position() function.","title":"position()"},{"location":"lualibxslt.html#last","text":"Return a number equal to the context size from the current XPath expression evaluation context. Equivalent to the XPath last() function.","title":"last()"},{"location":"lualibxslt.html#nodeset","text":"Return a new empty nodeset.","title":"nodeset()"},{"location":"luaxmldoc.html","text":"XML Document XML documents are available via the following properties and methods: Properties Document properties are read only variables. doc:name string = doc:name The document name. doc:url string = doc:url The document's URL. doc:root node = doc:root The document's root node. Methods doc:node() local node = doc:node() Create a new node belonging to the document. doc:setroot() old_root = doc:setroot(node) Set the document's root node to node . Returns the old root node. doc:serialize() doc:serialize(func) doc:serialize(function (text) io.write (text) end) Serialise the XML document. The argument is a function repeatedly called to write the resulting text.","title":"XML doc"},{"location":"luaxmldoc.html#xml-document","text":"XML documents are available via the following properties and methods:","title":"XML Document"},{"location":"luaxmldoc.html#properties","text":"Document properties are read only variables.","title":"Properties"},{"location":"luaxmldoc.html#docname","text":"string = doc:name The document name.","title":"doc:name"},{"location":"luaxmldoc.html#docurl","text":"string = doc:url The document's URL.","title":"doc:url"},{"location":"luaxmldoc.html#docroot","text":"node = doc:root The document's root node.","title":"doc:root"},{"location":"luaxmldoc.html#methods","text":"","title":"Methods"},{"location":"luaxmldoc.html#docnode","text":"local node = doc:node() Create a new node belonging to the document.","title":"doc:node()"},{"location":"luaxmldoc.html#docsetroot","text":"old_root = doc:setroot(node) Set the document's root node to node . Returns the old root node.","title":"doc:setroot()"},{"location":"luaxmldoc.html#docserialize","text":"doc:serialize(func) doc:serialize(function (text) io.write (text) end) Serialise the XML document. The argument is a function repeatedly called to write the resulting text.","title":"doc:serialize()"},{"location":"luaxmlnode.html","text":"XML Nodes Attention Lua XML documentation is still incomplete XML element nodes are made available with the following API. Properties node:name local string = node:name node:root local root = node:root node:document local doc = node:document node:local_name local string = node:local_name node:prefix local string = node:prefix node:namespace_uri local string = node:namespace_uri node:attr node:attr[name] = text local attr = node:attr[name] Set or retrieve an attribute value belonging to the node. Equivalent to the setattr() and getattr() methods respectively. node:parent local node = node:parent node:next_sibling local sibling = node:next_sibling node:previous_sibling local sibling = node:previous_sibling node:first_child local child = node:first_child node:last_child local child = node:last_child Methods node:append_child() node:append_child(child) child: child to append Append child to the end of the node's child list. node:children() local child for child in node:children() do -- process child end Return an iterator function for the node's children. This is a more convenient alternative to explicitly looping through nodes from node:first_child to node:last_child via the child:next_sibling properties. node:setattr() node:setattr(name, value) name: string with name of attribute value: string with text value of attribute Set the value of the node's attribute (property). node:getattr() value = node:getattr(name) name: string with name of attribute Return a string with the value of the node's property. node:unsetattr() node:unsetattr(name) name: string with name of attribute to remove. Remove attribute. node:copy() node:copy() node:replace() node:replace() node:unlink() node:unlink() node:new() node:new(name) name: string with new node local-name Create a new node belonging to the same document as the reference node. node:text() node:text(content) content: string with new text content Create a new text node belonging to the same document as the reference node. node:parse() node:parse(content) content: string with content to parse Parse a string containing a well-balanced XML chunk and add the result to the reference node's list of children. node:serialize() node:serialize(func) node:serialize(function (text) io.write (text) end) func: writer function. Serialise the XML document. The argument is a function repeatedly called to write the resulting text. node:nodeset() local node_set = node:nodeset() Create a new nodeset containing the node. node:newattr() node:attr(name,text) name: string with attribute name. text: string with text content for the attribute. Create a new attribute on the node with the specified name and content. tostring() The Lua tostring() function returns the string value of the element content. Operators The following operators are defined = : < : <= :","title":"XML node"},{"location":"luaxmlnode.html#xml-nodes","text":"Attention Lua XML documentation is still incomplete XML element nodes are made available with the following API.","title":"XML Nodes"},{"location":"luaxmlnode.html#properties","text":"","title":"Properties"},{"location":"luaxmlnode.html#nodename","text":"local string = node:name","title":"node:name"},{"location":"luaxmlnode.html#noderoot","text":"local root = node:root","title":"node:root"},{"location":"luaxmlnode.html#nodedocument","text":"local doc = node:document","title":"node:document"},{"location":"luaxmlnode.html#nodelocal_name","text":"local string = node:local_name","title":"node:local_name"},{"location":"luaxmlnode.html#nodeprefix","text":"local string = node:prefix","title":"node:prefix"},{"location":"luaxmlnode.html#nodenamespace_uri","text":"local string = node:namespace_uri","title":"node:namespace_uri"},{"location":"luaxmlnode.html#nodeattr","text":"node:attr[name] = text local attr = node:attr[name] Set or retrieve an attribute value belonging to the node. Equivalent to the setattr() and getattr() methods respectively.","title":"node:attr"},{"location":"luaxmlnode.html#nodeparent","text":"local node = node:parent","title":"node:parent"},{"location":"luaxmlnode.html#nodenext_sibling","text":"local sibling = node:next_sibling","title":"node:next_sibling"},{"location":"luaxmlnode.html#nodeprevious_sibling","text":"local sibling = node:previous_sibling","title":"node:previous_sibling"},{"location":"luaxmlnode.html#nodefirst_child","text":"local child = node:first_child","title":"node:first_child"},{"location":"luaxmlnode.html#nodelast_child","text":"local child = node:last_child","title":"node:last_child"},{"location":"luaxmlnode.html#methods","text":"","title":"Methods"},{"location":"luaxmlnode.html#nodeappend_child","text":"node:append_child(child) child: child to append Append child to the end of the node's child list.","title":"node:append_child()"},{"location":"luaxmlnode.html#nodechildren","text":"local child for child in node:children() do -- process child end Return an iterator function for the node's children. This is a more convenient alternative to explicitly looping through nodes from node:first_child to node:last_child via the child:next_sibling properties.","title":"node:children()"},{"location":"luaxmlnode.html#nodesetattr","text":"node:setattr(name, value) name: string with name of attribute value: string with text value of attribute Set the value of the node's attribute (property).","title":"node:setattr()"},{"location":"luaxmlnode.html#nodegetattr","text":"value = node:getattr(name) name: string with name of attribute Return a string with the value of the node's property.","title":"node:getattr()"},{"location":"luaxmlnode.html#nodeunsetattr","text":"node:unsetattr(name) name: string with name of attribute to remove. Remove attribute.","title":"node:unsetattr()"},{"location":"luaxmlnode.html#nodecopy","text":"node:copy()","title":"node:copy()"},{"location":"luaxmlnode.html#nodereplace","text":"node:replace()","title":"node:replace()"},{"location":"luaxmlnode.html#nodeunlink","text":"node:unlink()","title":"node:unlink()"},{"location":"luaxmlnode.html#nodenew","text":"node:new(name) name: string with new node local-name Create a new node belonging to the same document as the reference node.","title":"node:new()"},{"location":"luaxmlnode.html#nodetext","text":"node:text(content) content: string with new text content Create a new text node belonging to the same document as the reference node.","title":"node:text()"},{"location":"luaxmlnode.html#nodeparse","text":"node:parse(content) content: string with content to parse Parse a string containing a well-balanced XML chunk and add the result to the reference node's list of children.","title":"node:parse()"},{"location":"luaxmlnode.html#nodeserialize","text":"node:serialize(func) node:serialize(function (text) io.write (text) end) func: writer function. Serialise the XML document. The argument is a function repeatedly called to write the resulting text.","title":"node:serialize()"},{"location":"luaxmlnode.html#nodenodeset","text":"local node_set = node:nodeset() Create a new nodeset containing the node.","title":"node:nodeset()"},{"location":"luaxmlnode.html#nodenewattr","text":"node:attr(name,text) name: string with attribute name. text: string with text content for the attribute. Create a new attribute on the node with the specified name and content.","title":"node:newattr()"},{"location":"luaxmlnode.html#tostring","text":"The Lua tostring() function returns the string value of the element content.","title":"tostring()"},{"location":"luaxmlnode.html#operators","text":"The following operators are defined = : < : <= :","title":"Operators"},{"location":"luaxpathnodeset.html","text":"XPath Nodeset Attention Lua XML documentation is still incomplete TODO","title":"XSL-T node-set"},{"location":"luaxpathnodeset.html#xpath-nodeset","text":"Attention Lua XML documentation is still incomplete TODO","title":"XPath Nodeset"},{"location":"misc-functions.html","text":"XPath Miscellaneous Functions if() xmlns:fn=\"https://iarthair.github.io/xpfunctions\" obj fn:if(obj, obj) obj fn:if(obj, obj, obj) Implement a conditional operator. Convert the first argument to boolean as if using the XPath boolean() function. If called with two arguments return the first argument if the condition is true otherwise return the second argument. If called with three arguments return the second argument if the condition is true otherwise return the final argument. Arguments may be of any type provided the first argument may be converted to boolean. Arguments 2 arguments: obj : evaluate as boolean and return if true obj : return if first argument is false 3 arguments: obj : evaluate as boolean obj : return if first argument is true obj : return if first argument is false Returns obj : matching argument","title":"Miscellaneous"},{"location":"misc-functions.html#xpath-miscellaneous-functions","text":"","title":"XPath Miscellaneous Functions"},{"location":"misc-functions.html#if","text":"xmlns:fn=\"https://iarthair.github.io/xpfunctions\" obj fn:if(obj, obj) obj fn:if(obj, obj, obj) Implement a conditional operator. Convert the first argument to boolean as if using the XPath boolean() function. If called with two arguments return the first argument if the condition is true otherwise return the second argument. If called with three arguments return the second argument if the condition is true otherwise return the final argument. Arguments may be of any type provided the first argument may be converted to boolean.","title":"if()"},{"location":"misc-functions.html#arguments","text":"2 arguments: obj : evaluate as boolean and return if true obj : return if first argument is false 3 arguments: obj : evaluate as boolean obj : return if first argument is true obj : return if first argument is false","title":"Arguments"},{"location":"misc-functions.html#returns","text":"obj : matching argument","title":"Returns"},{"location":"regexp.html","text":"Posix Regular Expressions The regular expression functions are modelled on those described at exslt.org . The exslt specification specifies Javascript style regular expressions, however these functions are implemented using Posix regular expression syntax since these functions are readily available on Unix like platforms. In all cases if a non-string argument is specified where a string is expected the argument is converted as if by using the XPath string() function. replace() xmlns:re=\"https://iarthair.github.io/posix-regex\" string re:replace(string, string, string, string) The re:replace() function replaces the parts of a string that match a Posix extended regular expression with the replacement string. Within the replacement strings, the following sequences are recognised: \\\\ - stands for a \\ sign. & - the matched substring (write as &amp; in XML documents). \\0 - the matched substring, synonym for & . \\p - the portion of the string that precedes the matched substring (prefix). \\s - the portion of the string that follows the matched substring (suffix). \\nnn - the nth matched substring. The following flag characters are recognised: i - perform a case insensitive search. g - global match; replace all occurrences of the pattern, otherwise replace only the first match. m - match-any-character operators don't match a newline. Arguments string : the string to be matched string : a Posix extended regular expression string : flags string : replacement string Note that the order of arguments follows exslt.org and differs from the corresponding XPath 2 function. Returns string : resulting string match() xmlns:re=\"https://iarthair.github.io/posix-regex\" object re:match(string, string, string?) The re:match() function lets you get hold of the substrings of the string passed as the first argument that match the captured parts of the regular expression passed as the second argument. The following flag characters specified in the optional final argument are recognised: i - perform a case insensitive search. g - global match m - match-any-character operators don't match a newline. The return value is a node set of <match> elements, each of whose string value is equal to a portion of the first argument string captured by the regular expression. Behaviour differs depending on whether the match is global. If the match is not global, the first match element has a value equal to the portion of the string matched by the entire regular expression. Subsequent elements have values equal to the corresponding submatches from the regular expression. If the match is global, each match element contains a portion of the string matched by the entire regular expression. Arguments string : the string to be matched string : a Posix extended regular expression string ?: optional flags argument. Equivalent to empty string if omitted. Returns node-set : a node set of <match> elements. test() xmlns:re=\"https://iarthair.github.io/posix-regex\" boolean re:test(string, string, string?) The re:test() function returns true if the string given as the first argument matches the regular expression given as the second argument. The following flag characters are recognised: - i - perform a case insensitive search. - m - match-any-character operators don't match a newline. Arguments string : the string to be matched string : a Posix extended regular expression string ?: optional flags argument. Equivalent to empty string if omitted. Returns boolean : whether the string matches. filter() xmlns:re=\"https://iarthair.github.io/posix-regex\" re:filter(node-set, string, string?) Filter the node-set specified by the first argument. Each node is converted to a string as if using the XPath string() function and if it matches the RE add it to the result node-set. The following flag characters are recognised: - i - perform a case insensitive search. - m - match-any-character operators don't match a newline. Arguments node-set : the nodes to be matched string : a Posix extended regular expression string ?: optional flags argument. Equivalent to empty string if omitted. Returns node-set : the filtered, possibly empty, node set.","title":"Posix RE"},{"location":"regexp.html#posix-regular-expressions","text":"The regular expression functions are modelled on those described at exslt.org . The exslt specification specifies Javascript style regular expressions, however these functions are implemented using Posix regular expression syntax since these functions are readily available on Unix like platforms. In all cases if a non-string argument is specified where a string is expected the argument is converted as if by using the XPath string() function.","title":"Posix Regular Expressions"},{"location":"regexp.html#replace","text":"xmlns:re=\"https://iarthair.github.io/posix-regex\" string re:replace(string, string, string, string) The re:replace() function replaces the parts of a string that match a Posix extended regular expression with the replacement string. Within the replacement strings, the following sequences are recognised: \\\\ - stands for a \\ sign. & - the matched substring (write as &amp; in XML documents). \\0 - the matched substring, synonym for & . \\p - the portion of the string that precedes the matched substring (prefix). \\s - the portion of the string that follows the matched substring (suffix). \\nnn - the nth matched substring. The following flag characters are recognised: i - perform a case insensitive search. g - global match; replace all occurrences of the pattern, otherwise replace only the first match. m - match-any-character operators don't match a newline.","title":"replace()"},{"location":"regexp.html#arguments","text":"string : the string to be matched string : a Posix extended regular expression string : flags string : replacement string Note that the order of arguments follows exslt.org and differs from the corresponding XPath 2 function.","title":"Arguments"},{"location":"regexp.html#returns","text":"string : resulting string","title":"Returns"},{"location":"regexp.html#match","text":"xmlns:re=\"https://iarthair.github.io/posix-regex\" object re:match(string, string, string?) The re:match() function lets you get hold of the substrings of the string passed as the first argument that match the captured parts of the regular expression passed as the second argument. The following flag characters specified in the optional final argument are recognised: i - perform a case insensitive search. g - global match m - match-any-character operators don't match a newline. The return value is a node set of <match> elements, each of whose string value is equal to a portion of the first argument string captured by the regular expression. Behaviour differs depending on whether the match is global. If the match is not global, the first match element has a value equal to the portion of the string matched by the entire regular expression. Subsequent elements have values equal to the corresponding submatches from the regular expression. If the match is global, each match element contains a portion of the string matched by the entire regular expression.","title":"match()"},{"location":"regexp.html#arguments_1","text":"string : the string to be matched string : a Posix extended regular expression string ?: optional flags argument. Equivalent to empty string if omitted.","title":"Arguments"},{"location":"regexp.html#returns_1","text":"node-set : a node set of <match> elements.","title":"Returns"},{"location":"regexp.html#test","text":"xmlns:re=\"https://iarthair.github.io/posix-regex\" boolean re:test(string, string, string?) The re:test() function returns true if the string given as the first argument matches the regular expression given as the second argument. The following flag characters are recognised: - i - perform a case insensitive search. - m - match-any-character operators don't match a newline.","title":"test()"},{"location":"regexp.html#arguments_2","text":"string : the string to be matched string : a Posix extended regular expression string ?: optional flags argument. Equivalent to empty string if omitted.","title":"Arguments"},{"location":"regexp.html#returns_2","text":"boolean : whether the string matches.","title":"Returns"},{"location":"regexp.html#filter","text":"xmlns:re=\"https://iarthair.github.io/posix-regex\" re:filter(node-set, string, string?) Filter the node-set specified by the first argument. Each node is converted to a string as if using the XPath string() function and if it matches the RE add it to the result node-set. The following flag characters are recognised: - i - perform a case insensitive search. - m - match-any-character operators don't match a newline.","title":"filter()"},{"location":"regexp.html#arguments_3","text":"node-set : the nodes to be matched string : a Posix extended regular expression string ?: optional flags argument. Equivalent to empty string if omitted.","title":"Arguments"},{"location":"regexp.html#returns_3","text":"node-set : the filtered, possibly empty, node set.","title":"Returns"},{"location":"script.html","text":"EXSLT Script Extension This module implements the <script> extension element decribed in exslt.org with a few minor differences. <script> xmlns:func=\"http://exslt.org/functions\" <func:script implements-prefix=ncname language=qname src=uri-reference archive=uri-reference/> The top-level <func:script> element provides an implementation of extension functions in the specified namespace. The function implementations may be provided as a separate resource or as element content. implements-prefix The implements-prefix attribute is an ncname expanded to a URI using the namespace declarations in scope for the script element. This URI is the namespace URI identifying the local name of the XPath extension functions being implemented. language A qname identifying programming language used for the extension. If the language value is not supported, the script element is ignored. src Optional URI for the resource containing the extension functions. A relative URI is resolved relative to the base URI of the script element. If omitted the script is read from the element content instead. Element content should be protected by enclosing it in a CDATA section or by using XML entities where these conflict with symbols used in the programming language. An example is given below. Important Currently the src property is not fully implemented, only resources that are pathnames identifying local files may be specified. archive Not implemented, ignored. Lua Currently the only supported script language is Lua 5.3 . The language property should be specified as Lua . Lua functions are exported when the script is compiled, by returning a table of functions where the key is a string naming the XPath function. For example the following will create the XPath functions my:func1() , my:func2() and my:func3() . Func3() illustrates that it is possible to create XPath functions with a closure. <xsl:stylesheet ... xmlns:func=\"http://exslt.org/functions\" xmlns:my=\"http://example.org/lua\" extension-element-prefixes=\"func\"> <func:script implements-prefix=\"my\" language=\"Lua\" src=\"functions.lua\"/> ... </xsl:stylesheet> -- content of functions.lua exports = {} function exports.func1(...) return \"\" end function exports.func2(...) return \"\" end function func3_factory() local closure_var = \"\" return function(...) -- do some work involving the closure variables return closure_var end end exports.func3 = func3_factory() return exports If the above example were implemented as script element content it would read as follows. In this case to avoid issues with CDATA quoting, multi-line comments and strings should be written as --[=[ ... ]=] and [=[ ... ]=] respectively. <xsl:stylesheet ... xmlns:func=\"http://exslt.org/functions\" xmlns:my=\"http://example.org/lua\" extension-element-prefixes=\"func\"> <func:script implements-prefix=\"my\" language=\"Lua\"> <![CDATA[ exports = {} function exports.func1(...) return \"\" end function exports.func2(...) return \"\" end function func3_factory() local closure_var = \"\" return function(...) -- do some work involving the closure variables return closure_var end end exports.func3 = func3_factory() return exports ]]> </func:script> ... </xsl:stylesheet>","title":"Scripts"},{"location":"script.html#exslt-script-extension","text":"This module implements the <script> extension element decribed in exslt.org with a few minor differences.","title":"EXSLT Script Extension"},{"location":"script.html#script","text":"xmlns:func=\"http://exslt.org/functions\" <func:script implements-prefix=ncname language=qname src=uri-reference archive=uri-reference/> The top-level <func:script> element provides an implementation of extension functions in the specified namespace. The function implementations may be provided as a separate resource or as element content.","title":"&lt;script>"},{"location":"script.html#implements-prefix","text":"The implements-prefix attribute is an ncname expanded to a URI using the namespace declarations in scope for the script element. This URI is the namespace URI identifying the local name of the XPath extension functions being implemented.","title":"implements-prefix"},{"location":"script.html#language","text":"A qname identifying programming language used for the extension. If the language value is not supported, the script element is ignored.","title":"language"},{"location":"script.html#src","text":"Optional URI for the resource containing the extension functions. A relative URI is resolved relative to the base URI of the script element. If omitted the script is read from the element content instead. Element content should be protected by enclosing it in a CDATA section or by using XML entities where these conflict with symbols used in the programming language. An example is given below. Important Currently the src property is not fully implemented, only resources that are pathnames identifying local files may be specified.","title":"src"},{"location":"script.html#archive","text":"Not implemented, ignored.","title":"archive"},{"location":"script.html#lua","text":"Currently the only supported script language is Lua 5.3 . The language property should be specified as Lua . Lua functions are exported when the script is compiled, by returning a table of functions where the key is a string naming the XPath function. For example the following will create the XPath functions my:func1() , my:func2() and my:func3() . Func3() illustrates that it is possible to create XPath functions with a closure. <xsl:stylesheet ... xmlns:func=\"http://exslt.org/functions\" xmlns:my=\"http://example.org/lua\" extension-element-prefixes=\"func\"> <func:script implements-prefix=\"my\" language=\"Lua\" src=\"functions.lua\"/> ... </xsl:stylesheet> -- content of functions.lua exports = {} function exports.func1(...) return \"\" end function exports.func2(...) return \"\" end function func3_factory() local closure_var = \"\" return function(...) -- do some work involving the closure variables return closure_var end end exports.func3 = func3_factory() return exports If the above example were implemented as script element content it would read as follows. In this case to avoid issues with CDATA quoting, multi-line comments and strings should be written as --[=[ ... ]=] and [=[ ... ]=] respectively. <xsl:stylesheet ... xmlns:func=\"http://exslt.org/functions\" xmlns:my=\"http://example.org/lua\" extension-element-prefixes=\"func\"> <func:script implements-prefix=\"my\" language=\"Lua\"> <![CDATA[ exports = {} function exports.func1(...) return \"\" end function exports.func2(...) return \"\" end function func3_factory() local closure_var = \"\" return function(...) -- do some work involving the closure variables return closure_var end end exports.func3 = func3_factory() return exports ]]> </func:script> ... </xsl:stylesheet>","title":"Lua"},{"location":"uri-functions.html","text":"XPath URI Functions base-uri() xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:base-uri(node-set?) Return the base URI of the specified node or the context node if the argument is omitted. Arguments node-set ?: use first node in node-set or context node if omitted. Returns string : the base URI. resolve-uri() xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:resolve-uri(string, string?) Resolve-uri() takes a base URI and a relative URI as arguments, and constructs an absolute URI. If either argument is not a string it is converted as if with the XPath string() function. Arguments string : relative URI. string ?: base URI or base URI of context node if omitted. Returns string : absolute URI","title":"URI"},{"location":"uri-functions.html#xpath-uri-functions","text":"","title":"XPath URI Functions"},{"location":"uri-functions.html#base-uri","text":"xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:base-uri(node-set?) Return the base URI of the specified node or the context node if the argument is omitted.","title":"base-uri()"},{"location":"uri-functions.html#arguments","text":"node-set ?: use first node in node-set or context node if omitted.","title":"Arguments"},{"location":"uri-functions.html#returns","text":"string : the base URI.","title":"Returns"},{"location":"uri-functions.html#resolve-uri","text":"xmlns:fn=\"https://iarthair.github.io/xpfunctions\" string fn:resolve-uri(string, string?) Resolve-uri() takes a base URI and a relative URI as arguments, and constructs an absolute URI. If either argument is not a string it is converted as if with the XPath string() function.","title":"resolve-uri()"},{"location":"uri-functions.html#arguments_1","text":"string : relative URI. string ?: base URI or base URI of context node if omitted.","title":"Arguments"},{"location":"uri-functions.html#returns_1","text":"string : absolute URI","title":"Returns"},{"location":"usage.html","text":"Using the Libxslt Extension Modules The extension modules are installed in libxslt's plugin directory, for example /usr/lib/libxslt-plugins . Extension modules placed there will be located automatically by libxslt or any program that uses it such as xsltproc . Usage Usage is straightforward. The documentation for each extension element or function includes the namespace URI to be used. This is declared in the <xsl:stylesheet> element in the usual way and the prefix is listed in the extension-element-prefixes attribute. Important Remember to add the prefix to extension-element-prefixes since this tells libxslt to load the plugin referenced by the associated URI. Forgetting to do this can be a frustrating source of errors in your stylesheet. For example if the prefix is ext and the URI is https://iarthair.github.io/xpfunctions they are declared in the XSL-T stylesheet follows as: <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:ext=\"https://iarthair.github.io/xpfunctions\" extension-element-prefixes=\"ext\"> ... </xsl:stylesheet> XPath functions may then be referenced via the namespace prefix in the usual way, for example to call the string-join() function: <xsl:template match=\"*\"> <xsl:value-of select=\"ext:string-join(*,' + ')\"/> </xsl:template> Similar considerations apply for extension elements. Non-standard Installation If installation is made to a non-standard plugin directory, set the environment variable LIBXSLT_PLUGINS_PATH to point to the appropriate directory. Note that this is not a colon separated list of directories, only a single directory may be specified. For example: $ LIBXSLT_PLUGINS_PATH=/path/to/modules xsltproc ss.xsl file.xml","title":"Usage"},{"location":"usage.html#using-the-libxslt-extension-modules","text":"The extension modules are installed in libxslt's plugin directory, for example /usr/lib/libxslt-plugins . Extension modules placed there will be located automatically by libxslt or any program that uses it such as xsltproc .","title":"Using the Libxslt Extension Modules"},{"location":"usage.html#usage","text":"Usage is straightforward. The documentation for each extension element or function includes the namespace URI to be used. This is declared in the <xsl:stylesheet> element in the usual way and the prefix is listed in the extension-element-prefixes attribute. Important Remember to add the prefix to extension-element-prefixes since this tells libxslt to load the plugin referenced by the associated URI. Forgetting to do this can be a frustrating source of errors in your stylesheet. For example if the prefix is ext and the URI is https://iarthair.github.io/xpfunctions they are declared in the XSL-T stylesheet follows as: <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:ext=\"https://iarthair.github.io/xpfunctions\" extension-element-prefixes=\"ext\"> ... </xsl:stylesheet> XPath functions may then be referenced via the namespace prefix in the usual way, for example to call the string-join() function: <xsl:template match=\"*\"> <xsl:value-of select=\"ext:string-join(*,' + ')\"/> </xsl:template> Similar considerations apply for extension elements.","title":"Usage"},{"location":"usage.html#non-standard-installation","text":"If installation is made to a non-standard plugin directory, set the environment variable LIBXSLT_PLUGINS_PATH to point to the appropriate directory. Note that this is not a colon separated list of directories, only a single directory may be specified. For example: $ LIBXSLT_PLUGINS_PATH=/path/to/modules xsltproc ss.xsl file.xml","title":"Non-standard Installation"}]}